/*
 * Interface/Wrapper for C functions generated by CasADi
 *
 * CasADi generated the following four files:
 * - auto_casadi_cost.c
 * - auto_casadi_grad.c
 * - auto_casadi_mapping_f1.c
 * - auto_casadi_mapping_f2.c
 * - auto_preconditioning_functions.c
 *
 * This file is autogenerated by Optimization Engine
 * See http://doc.optimization-engine.xyz
 *
 *
 * Metadata:
 * + Optimizer
 *   + name: navigation
 *   + version: 0.0.0
 *   + licence: MIT
 * + Problem
 *   + vars: 20
 *   + parameters: 6
 *   + n1: 0
 *   + n2: 0
 *
 */
#include <stdlib.h>

/*
 * This is to be used ONLY for DEBUG purposes
 * Compile with -DTEST_INTERFACE
 */
#ifdef TEST_INTERFACE
#include <stdio.h>
#endif

#include "casadi_memory.h"

/* Number of input variables */
#define NU_NAVIGATION 20

/* Number of static parameters */
#define NP_NAVIGATION 6

/* Dimension of F1 (number of ALM constraints) */
#define N1_NAVIGATION 0

/* Dimension of F2 (number of PM constraints) */
#define N2_NAVIGATION 0

/* Dimension of xi = (c, y) */
#define NXI_NAVIGATION 0

/* Preconditioning Flag */



#ifndef casadi_real
#define casadi_real double
#endif

#ifndef casadi_int
#define casadi_int long long int
#endif


/* ------EXTERNAL FUNCTIONS (DEFINED IN C FILES)-------------------------------- */

/*
 * CasADi interface for the cost function
 */
extern int open_phi_navigation(
    const casadi_real** arg,
    casadi_real** res,
    casadi_int* iw,
    casadi_real* w,
    void* mem);

/*
 * CasADi interface for the gradient of the cost
 */
extern int open_grad_phi_navigation(
    const casadi_real** arg,
    casadi_real** res,
    casadi_int* iw,
    casadi_real* w,
    void* mem);

/*
 * CasADi interface for the gradient of mapping F1
 */
extern int open_mapping_f1_navigation(
    const casadi_real** arg,
    casadi_real** res,
    casadi_int* iw,
    casadi_real* w,
    void* mem);

/*
 * CasADi interface for the gradient of mapping F2
 */
extern int open_mapping_f2_navigation(
    const casadi_real** arg,
    casadi_real** res,
    casadi_int* iw,
    casadi_real* w,
    void* mem);

//#ifdef PRECONDITIONING_NAVIGATION
/*
 * CasADi interface for cost function preconditioning
 */
extern int open_preconditioning_w_cost_navigation(
    const casadi_real** arg,
    casadi_real** res,
    casadi_int* iw,
    casadi_real* w,
    void* mem);

/*
 * CasADi interface for f1 constraints preconditioning
 */
extern int open_preconditioning_w_f1_navigation(
    const casadi_real** arg,
    casadi_real** res,
    casadi_int* iw,
    casadi_real* w,
    void* mem);

/*
 * CasADi interface for f2 constraints preconditioning
 */
extern int open_preconditioning_w_f2_navigation(
    const casadi_real** arg,
    casadi_real** res,
    casadi_int* iw,
    casadi_real* w,
    void* mem);

/*
 * CasADi interface for initial penalty
 */
extern int open_initial_penalty_navigation(
    const casadi_real** arg,
    casadi_real** res,
    casadi_int* iw,
    casadi_real* w,
    void* mem);


/* ------WORKSPACES------------------------------------------------------------- */

/*
 * Integer workspaces
 */
#if COST_SZ_IW_NAVIGATION > 0
static casadi_int allocated_i_workspace_cost[COST_SZ_IW_NAVIGATION];  /* cost (int )  */
#else
static casadi_int *allocated_i_workspace_cost = NULL;
#endif

#if GRAD_SZ_IW_NAVIGATION > 0
static casadi_int allocated_i_workspace_grad[GRAD_SZ_IW_NAVIGATION];  /* grad (int )  */
#else
static casadi_int *allocated_i_workspace_grad = NULL;
#endif

#if F1_SZ_IW_NAVIGATION > 0
static casadi_int allocated_i_workspace_f1[F1_SZ_IW_NAVIGATION];      /* f1 (int )    */
#else
static casadi_int *allocated_i_workspace_f1 = NULL;
#endif

#if F2_SZ_IW_NAVIGATION > 0
static casadi_int allocated_i_workspace_f2[F2_SZ_IW_NAVIGATION];      /* f2 (int )    */
#else
static casadi_int *allocated_i_workspace_f2 = NULL;
#endif

#if W_COST_SZ_IW_NAVIGATION > 0
static casadi_int allocated_i_workspace_w_cost[W_COST_SZ_IW_NAVIGATION];      /* w_cost (int )    */
#else
static casadi_int *allocated_i_workspace_w_cost = NULL;
#endif

#if W1_SZ_IW_NAVIGATION > 0
static casadi_int allocated_i_workspace_w1[W1_SZ_IW_NAVIGATION];      /* w1 (int )    */
#else
static casadi_int *allocated_i_workspace_w1 = NULL;
#endif

#if W2_SZ_IW_NAVIGATION > 0
static casadi_int allocated_i_workspace_w2[W2_SZ_IW_NAVIGATION];      /* w2 (int )    */
#else
static casadi_int *allocated_i_workspace_w2 = NULL;
#endif

#if INIT_PENALTY_SZ_IW_NAVIGATION > 0
static casadi_int allocated_i_workspace_init_penalty[INIT_PENALTY_SZ_IW_NAVIGATION];      /* init_penalty (int )    */
#else
static casadi_int *allocated_i_workspace_init_penalty = NULL;
#endif


/*
 * Real workspaces
 */
#if COST_SZ_W_NAVIGATION > 0
static casadi_real allocated_r_workspace_cost[COST_SZ_W_NAVIGATION];  /* cost (real)  */
#else
static casadi_real *allocated_r_workspace_cost = NULL;
#endif


#if GRAD_SZ_W_NAVIGATION > 0
static casadi_real allocated_r_workspace_grad[GRAD_SZ_W_NAVIGATION];  /* grad (real ) */
#else
static casadi_real *allocated_r_workspace_grad = NULL;
#endif

#if F1_SZ_W_NAVIGATION > 0
static casadi_real allocated_r_workspace_f1[F1_SZ_W_NAVIGATION];      /* f1 (real )   */
#else
static casadi_real *allocated_r_workspace_f1 = NULL;
#endif

#if F2_SZ_W_NAVIGATION > 0
static casadi_real allocated_r_workspace_f2[F2_SZ_W_NAVIGATION];      /* f2 (real )   */
#else
static casadi_real *allocated_r_workspace_f2 = NULL;
#endif

#if W_COST_SZ_W_NAVIGATION > 0
static casadi_real allocated_r_workspace_w_cost[W_COST_SZ_W_NAVIGATION];      /* w_cost (real )   */
#else
static casadi_real *allocated_r_workspace_w_cost = NULL;
#endif

#if W1_SZ_W_NAVIGATION > 0
static casadi_real allocated_r_workspace_w1[W1_SZ_W_NAVIGATION];      /* w1 (real )   */
#else
static casadi_real *allocated_r_workspace_w1 = NULL;
#endif

#if W2_SZ_W_NAVIGATION > 0
static casadi_real allocated_r_workspace_w2[W2_SZ_W_NAVIGATION];      /* w2 (real )   */
#else
static casadi_real *allocated_r_workspace_w2 = NULL;
#endif

#if INIT_PENALTY_SZ_W_NAVIGATION > 0
static casadi_real allocated_r_workspace_init_penalty[INIT_PENALTY_SZ_W_NAVIGATION];      /* init_penalty (real )   */
#else
static casadi_real *allocated_r_workspace_init_penalty = NULL;
#endif

/*
 * Result workspaces
 */
#if COST_SZ_RES_NAVIGATION > 0
static casadi_real *result_space_cost[COST_SZ_RES_NAVIGATION];       /* cost (res )  */
#else
static casadi_real **result_space_cost = NULL;
#endif

#if GRAD_SZ_RES_NAVIGATION > 0
static casadi_real *result_space_grad[GRAD_SZ_RES_NAVIGATION];        /* grad (res )  */
#else
static casadi_real **result_space_grad = NULL;
#endif


#if F1_SZ_RES_NAVIGATION > 0
static casadi_real *result_space_f1[F1_SZ_RES_NAVIGATION];            /* f1 (res )    */
#else
static casadi_real **result_space_f1 = NULL;
#endif


#if F2_SZ_RES_NAVIGATION > 0
static casadi_real *result_space_f2[F2_SZ_RES_NAVIGATION];            /* f2 (res )    */
#else
static casadi_real **result_space_f2 = NULL;
#endif


#if W_COST_SZ_RES_NAVIGATION > 0
static casadi_real *result_space_w_cost[W_COST_SZ_RES_NAVIGATION];            /* w_cost (res )    */
#else
static casadi_real **result_space_w_cost = NULL;
#endif


#if W1_SZ_RES_NAVIGATION > 0
static casadi_real *result_space_w1[W1_SZ_RES_NAVIGATION];            /* w1 (res )    */
#else
static casadi_real **result_space_w1 = NULL;
#endif


#if W2_SZ_RES_NAVIGATION > 0
static casadi_real *result_space_w2[W2_SZ_RES_NAVIGATION];            /* w2 (res )    */
#else
static casadi_real **result_space_w2 = NULL;
#endif


#if INIT_PENALTY_SZ_RES_NAVIGATION > 0
static casadi_real *result_space_init_penalty[INIT_PENALTY_SZ_RES_NAVIGATION];            /* init_penalty (res )    */
#else
static casadi_real **result_space_init_penalty = NULL;
#endif



/* ------U, XI, P, W------------------------------------------------------------ */

/*
 * Space for storing (u, xi, p, w)
 * that is, uxip_space = [u, xi, p, w]
 *
 * The memory layout of the u-xi-p-w space is described below
 *
 * | --- | -- 0
 * |     |
 * |  u  |
 * |     |
 * | --- |
 *
 * | --- | -- NU
 * |     |
 * |  xi |
 * |     |
 * | --- |
 *
 * | --- | -- NU + NXI
 * |     |
 * |  p  |
 * |     |
 * | --- |
 *
 * | --- |
 * | wc  | -- NU + NXI + NP
 * | --- |
 *
 * | --- | -- NU + NXI + NP + 1
 * |     |
 * |  w1 |
 * |     |
 * | --- |
 *
 * | --- | -- NU + NXI + NP + N1 + 1
 * |     |
 * |  w2 |
 * |     |
 * | --- |
 *
 */

#define IDX_XI_NAVIGATION NU_NAVIGATION
#define IDX_P_NAVIGATION  IDX_XI_NAVIGATION + NXI_NAVIGATION
#define IDX_WC_NAVIGATION IDX_P_NAVIGATION + NP_NAVIGATION
#define IDX_W1_NAVIGATION IDX_WC_NAVIGATION + 1
#define IDX_W2_NAVIGATION IDX_W1_NAVIGATION + N1_NAVIGATION
#define N_UXIPW_NAVIGATION IDX_W2_NAVIGATION + N2_NAVIGATION

static casadi_real uxip_space[N_UXIPW_NAVIGATION];

/**
 * Return scaling factor of cost function (getter)
 */
casadi_real get_w_cost_navigation(void) {
    return uxip_space[IDX_WC_NAVIGATION];
}

/**
 * This function should be called upon initialisation. The sets all w's to 1.
 */
void init_interface_navigation(void) {
    unsigned int i;
    unsigned int offset = IDX_WC_NAVIGATION;
    unsigned int len = N1_NAVIGATION + N2_NAVIGATION + 1;
    for (i = 0; i < len; i++) {
        uxip_space[offset + i] = 1.0;
    }
}

/**
 * Copy (u, xi, p) into uxip_space
 *
 * Input arguments:
 * - `arg = {u, xi, p}`, where `u`, `xi` and `p` are pointer-to-double
 */
static void copy_args_into_uxip_space(const casadi_real** arg) {
    unsigned int i;
    for (i=0; i<NU_NAVIGATION; i++)  uxip_space[i] = arg[0][i];  /* copy u  */
    for (i=0; i<NXI_NAVIGATION; i++) uxip_space[IDX_XI_NAVIGATION+i] = arg[1][i];  /* copy xi */
    for (i=0; i<NP_NAVIGATION; i++)  uxip_space[IDX_P_NAVIGATION+i] = arg[2][i];  /* copy p  */
}


 /**
 * Copy (u, p) into uxip_space
 *
 * Input arguments:
 * - `arg = {u, p}`, where `u` and `p` are pointer-to-double
 */
static void copy_args_into_up_space(const casadi_real** arg) {
    unsigned int i;
    for (i=0; i<NU_NAVIGATION; i++) uxip_space[i] = arg[0][i];  /* copy u  */
    for (i=0; i<NP_NAVIGATION; i++) uxip_space[IDX_P_NAVIGATION+i] = arg[1][i];  /* copy p  */
}


/**
 * Cost function
 *
 * Input arguments:
 * - `arg = {u, xi, p}`, where `u`, `xi`, and `p` are pointer-to-double
 * - `res = {cost}`, where `cost` is a pointer-to-double
 */
int cost_function_navigation(const casadi_real** arg, casadi_real** res) {
    const casadi_real* args__[COST_SZ_ARG_NAVIGATION] =
             {uxip_space,  /* :u  */
              uxip_space + IDX_XI_NAVIGATION,   /* :xi  */
              uxip_space + IDX_P_NAVIGATION };  /* :p  */
    copy_args_into_uxip_space(arg);

    result_space_cost[0] = res[0];
    return open_phi_navigation(
        args__,
        result_space_cost,
        allocated_i_workspace_cost,
        allocated_r_workspace_cost,
        (void*) 0);
}


/**
 * Gradient function
 *
 * Input arguments:
 * - `arg = {u, xi, p}`, where `u`, `xi`, and `p` are pointer-to-double
 * - `res = {grad}`, where `grad` is a pointer-to-double
 */
int grad_cost_function_navigation(const casadi_real** arg, casadi_real** res) {
    const casadi_real* args__[GRAD_SZ_ARG_NAVIGATION] =
            { uxip_space,  /* :u  */
              uxip_space + IDX_XI_NAVIGATION,  /* :xi  */
              uxip_space + IDX_P_NAVIGATION};  /* :p   */
    copy_args_into_uxip_space(arg);
    result_space_grad[0] = res[0];
    return open_grad_phi_navigation(
        args__,
        result_space_grad,
        allocated_i_workspace_grad,
        allocated_r_workspace_grad,
        (void*) 0);
}

/**
 * Mapping F1
 *
 * Input arguments:
 * - `arg = {u, p}`, where `u` and `p` are pointer-to-double
 * - `res = {F1}`, where `F1` is a pointer-to-double
 */
int mapping_f1_function_navigation(const casadi_real** arg, casadi_real** res) {
    /* Array of pointers to where (u, p) are stored */
    const casadi_real* args__[F1_SZ_ARG_NAVIGATION] =
            {uxip_space,  /* :u   */
            uxip_space + IDX_P_NAVIGATION};  /* :p  */
    /* Copy given data to variable `uxip_space` */
    copy_args_into_up_space(arg);
    /*
     * The result should be written in result_space_f1
     * (memory has been allocated - see beginning of this file)
     */
    result_space_f1[0] = res[0];
    /*
     * Call auto-generated function open_mapping_f1_navigation
     * Implemented in: icasadi/extern/auto_casadi_mapping_f1.c
     */
    return open_mapping_f1_navigation(
        args__,
        result_space_f1,
        allocated_i_workspace_f1,
        allocated_r_workspace_f1,
        (void*) 0);
}


/**
 * Mapping F2
 *
 * Input arguments:
 * - `arg = {u, p}`, where `u` and `p` are pointer-to-double
 * - `res = {F1}`, where `F1` is a pointer-to-double
 */
int mapping_f2_function_navigation(const casadi_real** arg, casadi_real** res) {
    /* Array of pointers to where (u, p) are stored */
    const casadi_real* args__[F2_SZ_ARG_NAVIGATION] =
            {uxip_space,  /* :u   */
             uxip_space + IDX_P_NAVIGATION};  /* :p   */
    /* Copy given data to variable `uxip_space` */
    copy_args_into_up_space(arg);
    /*
     * The result should be written in result_space_f2
     * (memory has been allocated - see beginning of this file)
     */
    result_space_f2[0] = res[0];
    /*
     * Call auto-generated function open_mapping_f2_navigation
     * Implemented in: icasadi/extern/auto_casadi_mapping_f2.c
     */
    return open_mapping_f2_navigation(
        args__,
        result_space_f2,
        allocated_i_workspace_f2,
        allocated_r_workspace_f2,
        (void*) 0);
}

/**
 * Interface to auto-generated CasADi function for w_cost(u, p)
 *
 * Input arguments:
 *  - arg = {u, theta}
 */
static int preconditioning_w_cost_function_navigation(const casadi_real** arg) {
    /* Array of pointers to where (u, p) are stored */
    const casadi_real* args__[W_COST_SZ_ARG_NAVIGATION] =
            {uxip_space,  /* :u   */
             uxip_space + IDX_P_NAVIGATION};  /* :p   */
    /* Copy given data to variable `uxip_space` */
    copy_args_into_up_space(arg);
    /*
     * The result should be written in result_space_w_cost
     * (memory has been allocated - see beginning of this file)
     */
    result_space_w_cost[0] = uxip_space + IDX_WC_NAVIGATION;
    /*
     * Call auto-generated function open_preconditioning_w_cost_navigation
     * Implemented in: icasadi/extern/auto_preconditioning_functions.c
     */
    return open_preconditioning_w_cost_navigation(
        args__,
        result_space_w_cost,
        allocated_i_workspace_w_cost,
        allocated_r_workspace_w_cost,
        (void*) 0);
}

/**
 * Interface to auto-generated CasADi function for w1(u, p), which computes an
 * n1-dimensional vector of scaling parameters
 */
static int preconditioning_w1_function_navigation(const casadi_real** arg) {
    /* Array of pointers to where (u, p) are stored */
    const casadi_real* args__[W1_SZ_ARG_NAVIGATION] =
            {uxip_space,  /* :u   */
             uxip_space + IDX_P_NAVIGATION};  /* :p   */
    /* Copy given data to variable `uxip_space` */
    copy_args_into_up_space(arg);
    /*
     * The result should be written in result_space_w1
     * (memory has been allocated - see beginning of this file)
     */
    result_space_w1[0] = uxip_space + IDX_W1_NAVIGATION;
    /*
     * Call auto-generated function open_preconditioning_w_f1_navigation
     * Implemented in: icasadi/extern/auto_preconditioning_functions.c
     */
    return open_preconditioning_w_f1_navigation(
        args__,
        result_space_w1,
        allocated_i_workspace_w1,
        allocated_r_workspace_w1,
        (void*) 0);
}

/**
 * Interface to auto-generated CasADi function for w2(u, p), which computes an
 * n2-dimensional vector of scaling parameters
 */
static int preconditioning_w2_function_navigation(const casadi_real** arg) {
    /* Array of pointers to where (u, p) are stored */
    const casadi_real* args__[W2_SZ_ARG_NAVIGATION] =
            {uxip_space,  /* :u   */
             uxip_space + IDX_P_NAVIGATION};  /* :p   */
    /* Copy given data to variable `uxip_space` */
    copy_args_into_up_space(arg);
    /*
     * The result should be written in result_space_w2
     * (memory has been allocated - see beginning of this file)
     */
    result_space_w2[0] = uxip_space + IDX_W2_NAVIGATION;
    /*
     * Call auto-generated function open_preconditioning_w_f2_navigation
     * Implemented in: icasadi/extern/auto_preconditioning_functions.c
     */
    return open_preconditioning_w_f2_navigation(
        args__,
        result_space_w2,
        allocated_i_workspace_w2,
        allocated_r_workspace_w2,
        (void*) 0);
}

/**
 * Interface to auto-generated CasADi function for rho_1(u, theta), which computes the initial
 * penalty parameter. Note that this is a function of u and theta = (p, w_cost, w1, w2) and the
 * caller needs to provide p, w_cost, w1 and w2
 *
 * Input arguments:
 *  - (in )   arg = {u, p}     pointers to u and p (NOT theta, just p); we don't need to provide the preconditioning
 *                             parameters because they are stored in `uxipw_space`; they are only computed once and
 *                             we don't need to move their values around
 *  - (out)   res = {init_penalty}   pointer to initial penalty
 *
 * Output arguments:
 *  - status code (0: all good)
 */
int init_penalty_function_navigation(const casadi_real** arg, casadi_real** res) {
    /* Array of pointers to where (u, p) are stored */
    const casadi_real* args__[INIT_PENALTY_SZ_ARG_NAVIGATION] =
            {uxip_space,  /* :u   */
             uxip_space + IDX_P_NAVIGATION};  /* :theta   */
    /* Copy given data to variable `uxip_space` */
    copy_args_into_up_space(arg);
    /*
     * The result should be written in result_space_init_penalty
     * (memory has been allocated - see beginning of this file)
     */
    result_space_init_penalty[0] = res[0];
    /*
     * Call auto-generated function 
     * Implemented in: icasadi/extern/auto_preconditioning_functions.c
     */
    return open_initial_penalty_navigation(
        args__,
        result_space_init_penalty,
        allocated_i_workspace_init_penalty,
        allocated_r_workspace_init_penalty,
        (void*) 0);
}

/**
 * Compute all preconditioning/scaling factors, w
 *
 * Input arguments:
 * - `arg = {u, p}`, where `u` and `p` are pointer-to-double
 */
int preconditioning_www_navigation(const casadi_real** arg) {
    int status_ = 0;
    status_ += preconditioning_w1_function_navigation(arg);
    status_ += preconditioning_w2_function_navigation(arg);
    status_ += preconditioning_w_cost_function_navigation(arg);
    return status_;
}

/*
 * This is to be used ONLY for DEBUG purposes
 * Compile with -DTEST_INTERFACE
 */
#if defined(TEST_INTERFACE) && defined(PRECONDITIONING_NAVIGATION)

static casadi_real u_test[NU_NAVIGATION];
static casadi_real p_test[NP_NAVIGATION];

static void init_up_test(void) {
    unsigned int i;
    for (i=0; i<NU_NAVIGATION; i++){
        u_test[i] = 20 + i;
    }
    for (i=0; i<NP_NAVIGATION; i++){
        p_test[i] = 1.5 + 15 * i;
    }
}

static void print_static_array(void){
    unsigned int i;
    for (i=0; i<NU_NAVIGATION; i++){
        printf("u[%2d] = %4.2f\n", i, uxip_space[i]);
    }
    for (i=0; i<NXI_NAVIGATION; i++){
        printf("xi[%2d] = %4.2f\n", i, uxip_space[IDX_XI_NAVIGATION+i]);
    }
    for (i=0; i<NP_NAVIGATION; i++){
        printf("p[%2d] = %4.2f\n", i, uxip_space[IDX_P_NAVIGATION+i]);
    }
    printf("w_cost = %g\n", uxip_space[IDX_WC_NAVIGATION]);
#if N1_NAVIGATION > 0
     for (i=0; i<N1_NAVIGATION; i++){
        printf("w1[%2d] = %g\n", i, uxip_space[IDX_W1_NAVIGATION+i]);
    }
#endif /* IF N1 > 0 */
#if N2_NAVIGATION > 0
     for (i=0; i<N2_NAVIGATION; i++){
        printf("w2[%2d] = %g\n", i, uxip_space[IDX_W2_NAVIGATION+i]);
    }
#endif /* IF N2 > 0 */
}

static casadi_real test_initial_penalty(void) {
    const casadi_real *args[2] = {u_test, p_test};
    casadi_real initial_penalty = -1.;
    casadi_real *res[1] = { &initial_penalty };
    init_penalty_function_navigation(args, res);
    return initial_penalty;
}

int main(void) {
    init_interface_navigation();
    init_up_test();
    const casadi_real *argz[2] = {u_test, p_test};
    preconditioning_www_navigation(argz);

    /*
     * Since this is invoked after `test_w_cost`, `test_w1` and `test_w2`, the ws have been computed previously
     * and are available in `uxipw_space`. The caller does need to provide them
     */
    casadi_real rho1 = test_initial_penalty();
    print_static_array();
    printf("rho1 = %g\n", rho1);
    return 0;
}

#endif /* END of TEST_INTERFACE and PRECONDITIONING_NAVIGATION */